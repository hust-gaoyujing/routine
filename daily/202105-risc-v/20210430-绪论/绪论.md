[TOC]



### 绪论

计算机的构成：

![image-20210507151708003](绪论.assets/image-20210507151708003.png)



汇编指令（机器指令的注记符）和机器指令一一对应



#### 1.介绍

1.后PC时代是什么？



#### 2.八大设计思想

1.依摩尔定律而设计：因为集成电路发展迅速，所以我们在设计初就应该考虑到项目结束时工艺等技术水平；

2.抽象思想简化设计：设计中的细节会随着技术的发展而随时改变，使用抽象的方式去定性不同层次的设计有助于避免设计时间的延长；

3.加速大概率事件：加速大概率事件有助于提高设计的性能，而且通常情况下大概率事件还更容易被设计和优化；

4.并行提高性能：并行设计有助于提高性能；

5.流水线提高性能：向一处火灾运水，所有人并排将水流水线式的传递过去肯定比一个人跑来跑去送的更快，当然这也需要有很多的人；

6.预测法提高效率：通常情况下通过预测和假设直接开始工作比直到你确定了结果才开始更快；

7.内存的按需分配：越快越贵的内存在使用中占少数，用在cache等这些数据流中间级的缓存，越慢越便宜的内存在使用中占多数，比如用来存储数据的flash等；

8.冗余增加可靠性：设计不仅要快还要稳定可靠，通过增加冗余提高设计的可靠性；



#### 3.编译

![image-20210508155552118](绪论.assets/image-20210508155552118.png)

应用软件程序都是使用高级语言实现的，但是我们的硬件只能识别0、1这些低级的机器语言，所以想让软件在硬件上实现就必须要有系统软件；系统软件包括**操作系统、编译器**、加载器、汇编器；

其中操作系统（主流操作系统有linux,ios,windows）的主要功能有：

- 处理输入输出操作
- 分配存储空间和内存
- 在多应用时提供保护



.c->.o的编译过程：

![编译过程](绪论.assets/编译过程.png)



![image-20210508165258715](绪论.assets/image-20210508165258715.png)

为什么不直接使用汇编或者机器语言而使用高级编程语言：

- 易读性
- 高效性
- 独立性（不需要考虑计算机本身）



#### 4.计算机内部

![image-20210508172057316](绪论.assets/image-20210508172057316.png)

处理器从存储器中得到指令和数据，输入部件将数据写入存储器，输出部件从存储器中读取数据，控制器向数据通路，存储器，输入部件，输出部件发送命令信号；

硬件设备的四个主要功能：输入数据、输出数据、处理数据、存储数据

计算机组成的五大部分：输入、输出、数据通路、控制、内存

输入：麦克风、键盘、触摸屏

输出：扬声器、显示屏

处理：包括数据通路和控制，

![image-20210509141820707](绪论.assets/image-20210509141820707.png)

双核系统必须使用仲裁器件来分配两个核心的资源使用，因此digital logic blocks可能就是这个作用；CPU应该集成在Processor Data Path中；512MB的内存位置未知；

核心面积 122mm^2

ARM核占12%   14.64mm^2

CPU+GPU 40%  47mm^2

存储：

易失性存储器-主存：SRAM DRAM只能在上电才能存储数据，读写快，用量小

非易失性存储器-二级存储器：磁盘，FLASH，在掉电也可以存储数据，读写慢一点，价格便宜



#### 5.性能

在挑选产品中，性能是极其重要的因素之一。在不同的应用场景，需要根据不同的性能标准作为判断条件：

**响应时间：** 也叫执行时间，是计算机完成某任务需要的总时间；

**吞吐率：** 也叫带宽，表示单位时间内完成的任务数量；多用户的服务器更关注吞吐率；



CPU性能及其因素
$$
一个程序的执行时间 = 一个程序的CPU时钟数 * 时钟周期时间
$$
或者
$$
一个程序的执行时间 = \frac{一个程序的CPU时钟数} {时钟频率}
$$


指令的性能
$$
CPU时钟数 = 程序的指令数*CPI
$$
eg : Suppose we have two implementations of the same instruction set architecture. Computer A has a clock cycle time of 250 ps and a CPI of 2.0 for some program, and computer B has a clock cycle time of 500 ps and a CPI of 1.2 for the same program. Which computer is faster for this program and by how much?

answer:
$$
{CPU_A}时钟数 = I*CPI = I*2.0 
$$

$$
{CPU_B}时钟数 = I*CPI = I*1.2
$$



![image-20210509222444378](绪论.assets/image-20210509222444378.png)



经典的CPU性能公式
$$
CPU时间 = 指令数*CPI*时钟周期时间
$$
或者
$$
CPU时间 = \frac{指令数*CPI}{时钟频率}
$$
可以利用这三个影响性能的因素，选择合适的设计方案来提高性能



CPI的计算：
$$
CPI = \frac{CPU时钟数}{指令数} = \frac{\sum_{i=1}^{n}{CPI_i}*{C_i}}{\sum_{i=1}^{n}{C_i}}
$$
只用一个因素去评价或者改善性能都是不可取的，在评价性能的过程中必要用同时考察三个因素才可以确定执行时间；当时钟频率相同时，单纯的减少指令数，也可能导致CPI的增加，因为CPI会随着指令组合改变而改变；反之亦然；



#### 6.功耗墙

25间Intel x86 八代微处理器时钟频率和功耗的增加：

![image-20210509232420781](绪论.assets/image-20210509232420781.png)
$$
功耗 \varpropto 1/2*负载电容*{电压^2}*开关频率
$$
虽然时钟频率增加了1000倍但是功耗只增加了30倍，因为每代的电压都减少了15%左右；

