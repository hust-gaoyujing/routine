### 指令集介绍

1.指令集要素：

​	指令类型与编码，寻址模式，数据结构

2.子程序调用：

​	store：保存现场

​	load：恢复现场



3.E200的RTL代码风格

​	使用专用的DFF模块例化生成寄存器；

​	推荐使用assign代替if-else和case语法；

​	由于带reset的寄存器面积和时许会稍微差一点，所以在数据通路可以使用不带reset的寄存器，而只在控制通路上使用带reset的寄存器；



4.处理器流水线

​	取指，译码，执行，访存，写回

​	状态机是流水线的取反；

​	

​	负面：

​	每一级流水线都是由寄存器组成，更多的流水线级数就需要消耗更多的寄存器，以及更大的面积开销；

​	每一级流水都需要进行握手，最后一级的反压信号可能会一直串扰到最前一级造成严重的时序问题；

​	流水线冲刷；



5.非对齐指令的处理

普通指令非对齐：使用剩余缓存保存上次取指令后没有用完的比特位，供下次使用；

分支跳转指令非对齐：使用多体化的SRAM进行指令存储；



6.明确的RAS依据

RISC-V架构中明确规定，如果使用JAL指令且目标寄存器索引值rd等于x1或者x5，则属于需要进行RAS压栈；如果使用jalr指令，则按照使用的寄存器值（rd和rs1）的不同，明确规定了相应的RAS压栈或者出栈行为。



7.对于无条件间接跳转指令jalr，当基地址来自rs1索引的操作数是X1，可以从EXU的Regfile中直接拉线取出，不需要占用Regfile的读端口。



8.复位后的第一次取指，CPU-TOP的顶层输入信号pc_rtvec指示的值作为第一次取指的PC值。



9.处理在指令的执行过程中可以乱序执行，但是如果后一个执行基于前一个执行结果怎么办？

数据冲突：将需要处理的指令分成两种  单周期  长周期（写回操作需要多个周期后才能完成）

数据相关性：



10.为了节省动态功耗，采用逻辑门控（logic gate）的方式，增加一级与门，对于子单元输入的信号与分组指示；可 以选择？ ： 判断方式来解决；



11.

wire [31:0] csr_i_rs1 = {32 {csr_op}}  & i_rs1;  

wire [31:0] csr_i_rs1 = csr_op ? i_rs1: 32'h0;   //great



选择对应子单元的ready信号作为反馈给上游派遣模块的ready握手信号。本质上该逻辑是使用and-or方式实现的并行多路选择器。

